
Page

of 28
ZOOM
ECS 150 - Filesystem Implementation
Prof. Joël Porquet-Lupine
UC Davis - WQ24
Copyright © 2017-2024 Joël Porquet-Lupine - CC BY-NC-SA 4.0 International License1 / 45
Volume
Disk, or partition on a disk
Large array of sectors/blocks
Filesystem
Methods and data structures to
organize files on a volume
Volume
File
Metadata to describe file's
characteristics
Actual sequence of data
Metadata
Data
- size: 42 KiB
- created: 1970-01-01
...
010111011001
101001110001
110111011000
....
Directory
Hierarchy of named files
File name directory File number
index
structure Storage
sectors
"foo.txt" 871music/ 320
work/ 219
foo.txt 871
Introduction
Concepts (recap)2 / 45
Design considerations
Workload (1)
File size and storage space
Most files are small...
$ du -sh /usr/bin/
1.1G /usr/bin/
$ ls -1 /usr/bin/ | wc -l
4566
But large files account for more storage
$ du -h VirtualBox/Machines/Ubuntu/Ubuntu.vdi
20G VirtualBox/Machines/Ubuntu/Ubuntu.vdi
File access and I/O transfer
Most accesses are to small files...
$ strace chrome |& grep "open" | wc -l
557
But accesses to large file account for more I/O transfer
$ dd if=Ubuntu.vdi of=copy.vdi bs=4K
...
20981043200 bytes (21 GB, 20 GiB) copied, 62.74 s, 334 MB/s3 / 45
Design considerations
Workload (2)
File access pattern
Most files are read/written sequentially
E.g., config files, executables
Some files are read/written randomly
E.g., database files, swap files
File size growth
Some files have pre-defined size at creation (e.g., downloaded files)
Some files start small and grow over time (e.g., system logs)
File lifetime
Some files always exist (e.g., OS files)
Some files exist just for an instant (e.g., intermediary compilation file)4 / 45
From small block size...
E.g., blocks of one single sector
each (512 bytes)
Management requires more space
More distinct accesses to data
Less wasted space if block not full
...to big block size
E.g., blocks of 32 KiB each (64
consecutive sectors)
Management requires less space
Performance improvement
Wasted space if block not full
Design considerations
Blocks vs disk sectors
Rationale
A disk sector is usally 512-bytes long
But OS typically allocates blocks of disk sectors rather than individual
sectors
Doesn't cost much more to access few consecutive disk sectors
Trade-off
Make block size multiple of memory page size
That is 4KiB on most systems
(Eight 512-byte consecutive disk sectors)5 / 45
Design considerations
Review
Small files
Ideally, should use small blocks for efficient storage
Files used together should be stored together
Large files
Ideally, should use large blocks for efficient storage
Contiguous data allocation for sequentially accessed files
Efficient lookup for randomly accessed files
Problems
May not know at file creation
Whether file will become small or large
Whether file will be used sequentially or randomly
Whether file is persistent or temporary6 / 45
Data structures
Directories
Map filenames to file numbers (to
find metadata)
Index structure
Part of a file's metadata
Map data blocks of file
Free space map
Manage the list of free disk blocks
Allow files to grow/shrink
Data structures organization
Storage devices often have
non-uniform performance
E.g., magnetic disks
Use of locality heuristics to
optimize data placement
Defragmentation
Files grouping
Design considerations
Implementation overview
From pair <filename, offset>, find physical storage block efficiently
File name,
Offset
directory File number
index
structure Storage
sectors
"foo.txt",
42
871music/ 320
work/ 219
foo.txt 8717 / 45
A directory is simply a file
List of mappings from filenames to file numbers
Each mapping is a directory entry
<name, file number>
Only directly accessible by OS
Ensure integrity of mapping
Accessible for processes via syscalls
e.g., opendir()/readdir()
Directories
Design
Hexdump of directory (Project #3)
-- Although note that in P3, we have a direct mapping from filename to the file's metadata8 / 45
Flat hierarchy
One unique namespace for the
entire volume
Use special area of the disk to
hold root directory
Two files can never be named
the same
Multi-user flat hierarchy
Separate root directory for each
user
But all user's files must still have
unique names...
Multi-user, multi-level hierarchy
One special root directory
Hierarchy of subdirectories
Permissions to distinguish
between users
Directories
Organization strategies9 / 45
Directories
Implementation
Linear layout
Simple array of entries
E.g., MS-FAT, ECS150FS
Pros/Cons
Simple
Need to scan all possible entries to find one10 / 45
Directories
List layout
Linked-list of entries
E.g., ext2 filesystem
Pros/Cons
Jump over blocks of free entries
Linear traversal of valid entries11 / 45
Directories
Tree layout
Tree of entries
Filenames hashed into keys used to traverse tree
E.g., XFS, NTFS
Pros/Cons
Fast search (~ )
Much more complicated to implement!
O(log N )12 / 45
Index structures
Metadata to data
From directory mapping, find metadata
From metadata, find file's contents
M
Metadata
File
Content
File ???
File name,
offset
"foo.txt",
42
music/
work/
foo.txt
320
219
871
Goals
Provide efficient sequential access to file's data
Provide efficient random access to any file offset
Limit overheads to be efficient for small files
Be scalable to support large files
Support file growing/shrinking13 / 45Index structures
Metadata to data
From directory mapping, find metadata
From metadata, find file's contents
M
Metadata
File
Content
File ???
File name,
offset
"foo.txt",
42
music/
work/
foo.txt
320
219
871
Goals
Provide efficient sequential access to file's data
Provide efficient random access to any file offset
Limit overheads to be efficient for small files
Be scalable to support large files
Support file growing/shrinking13 / 45
Pros
Very simple
Best performance
Efficient sequential and random
access
Cons
Change in size likely to require
entire reallocation
External fragmentation
Usage
ISO 9660 (CD-ROM, DVD, BD)
Index structures
Contiguous allocation
Files stored as a sequence of contiguous blocks
File-to-blocks mapping includes first block (and size)
Require allocation policy (e.g., first-fit, best-fit, worst-fit)
Example
M
Metadata
File 1
Content
File 1
Metadata
File 2
Content
File 2
M
0 1 2 3 4 5 6 7 8 914 / 45Pros
Very simple
Best performance
Efficient sequential and random
access
Cons
Change in size likely to require
entire reallocation
External fragmentation
Usage
ISO 9660 (CD-ROM, DVD, BD)
Index structures
Contiguous allocation
Files stored as a sequence of contiguous blocks
File-to-blocks mapping includes first block (and size)
Require allocation policy (e.g., first-fit, best-fit, worst-fit)
Example
M
Metadata
File 1
Content
File 1
Metadata
File 2
Content
File 2
M
0 1 2 3 4 5 6 7 8 914 / 45
Index structures
Digression about fragmentation
Internal fragmentation
Waster space inside blocks
Issue if blocks are too large
File 1
File 2
File 3
External fragmentation
Free space is scattered instead of being contiguous
Issue if blocks have to be allocated contiguously
File 1
File 2
File 3
File 4
(Example: needs 4 free blocks for File 4: they exist but aren't contiguous)15 / 45Index structures
Digression about fragmentation
Internal fragmentation
Waster space inside blocks
Issue if blocks are too large
File 1
File 2
File 3
External fragmentation
Free space is scattered instead of being contiguous
Issue if blocks have to be allocated contiguously
File 1
File 2
File 3
File 4
(Example: needs 4 free blocks for File 4: they exist but aren't contiguous)15 / 45
Pros
Fairly simple
File size flexibility
No external fragmentation
Easy sequential access
Cons
Potentially inefficient sequential
access
No (true) random access
Usage
MS-FAT, ECS150FS
Index structures
Linked-list allocation
Files stored as linked lists of blocks
File-to-blocks mapping includes pointer to the first block
For each block, pointer to the next block in chain
Possibly, pointer to the last block to optimize file growth
Example
M
Metadata
File 1
Metadata
File 2
M
0 1 2 3 4 5 6 7 8 9 1016 / 45Pros
Fairly simple
File size flexibility
No external fragmentation
Easy sequential access
Cons
Potentially inefficient sequential
access
No (true) random access
Usage
MS-FAT, ECS150FS
Index structures
Linked-list allocation
Files stored as linked lists of blocks
File-to-blocks mapping includes pointer to the first block
For each block, pointer to the next block in chain
Possibly, pointer to the last block to optimize file growth
Example
M
Metadata
File 1
Metadata
File 2
M
0 1 2 3 4 5 6 7 8 9 1016 / 45
ECS 150 - Filesystem Implementation
Prof. Joël Porquet-Lupine
UC Davis - WQ24
Copyright © 2017-2024 Joël Porquet-Lupine - CC BY-NC-SA 4.0 International License17 / 45ECS 150 - Filesystem Implementation
Prof. Joël Porquet-Lupine
UC Davis - WQ24
Copyright © 2017-2024 Joël Porquet-Lupine - CC BY-NC-SA 4.0 International License17 / 45
Directories Index structures
Contiguous allocation
M
Metadata
File 1
Content
File 1
Metadata
File 2
Content
File 2
M
0 1 2 3 4 5 6 7 8 9
Linked-list allocation
M
Metadata
File 1
Metadata
File 2
M
0 1 2 3 4 5 6 7 8 9 10
Recap
Implementation overview
From pair <filename, offset>, find physical storage block efficiently
File name,
Offset
directory File number
index
structure Storage
sectors
"foo.txt",
42
871music/ 320
work/ 219
foo.txt 87118 / 45Directories Index structures
Contiguous allocation
M
Metadata
File 1
Content
File 1
Metadata
File 2
Content
File 2
M
0 1 2 3 4 5 6 7 8 9
Linked-list allocation
M
Metadata
File 1
Metadata
File 2
M
0 1 2 3 4 5 6 7 8 9 10
Recap
Implementation overview
From pair <filename, offset>, find physical storage block efficiently
File name,
Offset
directory File number
index
structure Storage
sectors
"foo.txt",
42
871music/ 320
work/ 219
foo.txt 87118 / 45
Pros
File size flexibility (no external
fragmentation)
Supports true random access
Cons
Limited file size
Non-scalable index structure
Index structures
Direct allocation
File-to-blocks mapping includes direct pointers to each data block
Example
M
Metadata
File
6
0 1
1
2
2
3
3
4 5 6 7 8 9
9
10
10
1119 / 45Pros
File size flexibility (no external
fragmentation)
Supports true random access
Cons
Limited file size
Non-scalable index structure
Index structures
Direct allocation
File-to-blocks mapping includes direct pointers to each data block
Example
M
Metadata
File
6
0 1
1
2
2
3
3
4 5 6 7 8 9
9
10
10
1119 / 45
Pros
Same as direct allocation
But decouple index structure from
metadata
Cons
Same as direct allocation
But overhead for small files
Index structures
Indexed allocation
File-to-blocks mapping includes a pointer to an index block
An index block contains an array of data block pointers
Data blocks allocated only on demand
Example
M
Metadata
File Index
Block
0 1 2 3 4 5 6 7 8 9 10
6
3 4
9 820 / 45Pros
Same as direct allocation
But decouple index structure from
metadata
Cons
Same as direct allocation
But overhead for small files
Index structures
Indexed allocation
File-to-blocks mapping includes a pointer to an index block
An index block contains an array of data block pointers
Data blocks allocated only on demand
Example
M
Metadata
File Index
Block
0 1 2 3 4 5 6 7 8 9 10
6
3 4
9 820 / 45
Pros
Can accommodate large files
Cons
Traversal for very large files
Index structures
Linked index blocks (IB + IB + ...)
Last index block's pointer can point to next index block
Example
M
Metadata
File
IB IB IB
0 10 11 12 131 2 3 4 5 6 7 8 921 / 45Pros
Can accommodate large files
Cons
Traversal for very large files
Index structures
Linked index blocks (IB + IB + ...)
Last index block's pointer can point to next index block
Example
M
Metadata
File
IB IB IB
0 10 11 12 131 2 3 4 5 6 7 8 921 / 45
Pros
Great support for very large files
Cons
Wasteful for small files
Index structures
Multilevel index blocks (IB x IB x ...)
First-level index block points onto second-level index blocks
Tree structure
Example
M
Metadata
File
IB IB IBIB
0 10 11 12 131 2 3 4 5 6 7 8 922 / 45
Index structure for files
Each file is a linked list of clusters
Free space map
Linear map of all clusters on disk
Data
Next
Data
Next
Data
Next
FAT Data blocks
Case study: MS-FAT
Introduction
Microsoft File Allocation Table
Originally created for floppy disks, in the late 70s
Used on MS-DOS, and early version of Windows (before NTFS)
Still very popular on certain systems (e.g., thumb drives, camera SD-cards,
embedded systems, etc.)
Different versions over time: FAT12, FAT16, FAT32, and now exFAT
File Allocation Table23 / 45
FAT structure
1 entry per cluster (data block)
FAT Data clusters
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
0
0
0
EOC
EOC
foo.txt (cluster #0)
foo.txt (cluster #1)
foo.txt (cluster #2)
foo.txt (cluster #4)
foo.txt (cluster #3)
bar.txt (cluster #0)
bar.txt (cluster #1)
17
10
11
3
16
Index structures
Directory entry maps name to first
cluster index
File Size Index
foo.txt 18000 9
bar.txt 5000 12
Indicates next cluster in chain
or EOC for last cluster of a file
Free space tracking
0 indicates free cluster
Locality heuristics
Usually simple allocation strategy
(e.g. next-fit)
Case study: MS-FAT24 / 45
Case study: MS-FAT
Directory structure
Directory is a file containing an array of 32-byte entries.
Each entry composed of
8-byte name + 3-byte extension (ASCII)
Long file names were later supported by allowing to chain multiple directory
entries
Creation date and time
Last modification date and time
Index of first cluster in FAT
Size of the file25 / 45
Case study: MS-FAT
Layout on disk26 / 45
Before
FAT Data clusters
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
0
0
0
EOC
EOC
foo.txt (cluster #0)
foo.txt (cluster #1)
foo.txt (cluster #2)
foo.txt (cluster #4)
foo.txt (cluster #3)
bar.txt (cluster #0)
bar.txt (cluster #1)
17
10
11
3
16
After
FAT Data clusters
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
EOC
17
foo.txt (cluster #0)
foo.txt (cluster #1)
foo.txt (cluster #2)
foo.txt (cluster #4)
foo.txt (cluster #3)
bar.txt (cluster #0)
bar.txt (cluster #1)
10
11
12
13
EOC
0
0
0
Case study: MS-FAT
Locality heuristics
Clusters for a file may be scattered across the disk
Defragmentation can rearrange clusters and improve spatial locality27 / 45
Case study: MS-FAT
Conclusion
Pros
Simple
State required per file: start cluster and size
Widely supported (maybe even the most popular FS ever!)
No external fragmentation (all available clusters can be allocated)
Cons
Limited performance
Many seeks if FAT cannot be cached in memory
Poor locality for sequential access if files are fragmented
Poor random access
Limited metadata
No access control
No support for hard links
Limited volume and file sizes
E.g., 2-TiB max volume and 4-GiB max file size with FAT32
No support for reliability strategies28 / 45
